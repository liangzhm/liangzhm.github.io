<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>和叶的空间</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://github.com/liangzhm/"/>
  <updated>2019-02-21T06:42:47.101Z</updated>
  <id>https://github.com/liangzhm/</id>
  
  <author>
    <name>liangzhm</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Cors介绍及实现方法</title>
    <link href="https://github.com/liangzhm/2019/02/21/Cors%E4%BB%8B%E7%BB%8D%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/"/>
    <id>https://github.com/liangzhm/2019/02/21/Cors介绍及实现方法/</id>
    <published>2019-02-21T06:33:54.000Z</published>
    <updated>2019-02-21T06:42:47.101Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是cors"><a href="#什么是cors" class="headerlink" title="什么是cors"></a>什么是cors</h1><p>CORS ，全称是Cross-origin resource sharing，意思是跨域资源共享，众所周知，对于ajax请求，浏览器是有同源策略的限制的，cors是一个W3C标准，用来避开同源策略。简单来说就是为了解决跨域问题的，我们知道，跨域技术有jsonp，但是jsonp只支持get请求，对于一些高级的请求比如post，delete，put等，jsonp就无能为力了，所以cors的优势就体现出来了。</p><h1 id="如何使用cors"><a href="#如何使用cors" class="headerlink" title="如何使用cors"></a>如何使用cors</h1><p>Cors的使用需要浏览器和服务器端同时配合。目前所有浏览器都支持，其中IE浏览器支持IE10以上。<br>使用cors的整个过程，前端无需做其他处理，正常发ajax请求即可，所以对于前端来说，使用cors通信和同源的ajax没有差别，代码完全一样。<br>浏览器一旦发现ajax请求的是跨域的资源，就会自动添加一些附加的header信息，有时候还会多出一次附加的请求，但是用户不会有察觉。<br>因此，实现cors关键是服务器。只要服务器配置了响应头，就可以实现跨域通信。<br>浏览器将cors请求分成两类，简单请求和非简单请求。get和post都是简单请求。</p><h2 id="简单请求："><a href="#简单请求：" class="headerlink" title="简单请求："></a>简单请求：</h2><ul><li><ol><li>在Request Headers中会自动添加一个额外的Origin头部，其中包含请求页面的资源信息（协议，域名和端口），以便服务器根据这个头部信息决定是否给予响应。<br>比如，我在本地搭了一套前端环境，搭了一套nodejs后端环境，前端请求页面是<a href="http://localhost:9898，服务器地址是http://localhost:7001" target="_blank" rel="noopener">http://localhost:9898，服务器地址是http://localhost:7001</a> 。如下图。</li></ol></li><li><ol start="2"><li>如果服务器认为这个请求可以接受，就在Access-Control-Allow-Origin 头<br>部中回应相同的源信息。如下图所示。Access-Control-Allow-Origin代表可以同意的跨域请求，这个字段也能设置为*号，代表同意任意的跨域请求。</li></ol></li><li><ol start="3"><li>如果没有这个头部或者有这个头部但是源信息不匹配，浏览器就会驳回请求。<br>正常情况下，浏览器会处理请求。这里需要注意的是，请求和响应都不包含 cookie 信息。<br>当前请求的域名是localhost:9898，但是服务器端返回的Access-Control-<br>Allow-Origin是localhost：9899，浏览器发现不一致，就会报错，报错信息中也显示localhost：9898不允许接入访问（也就是跨域了）。</li></ol></li></ul><p>报错信息如下图所示：</p><ul><li><ol start="4"><li>CORS请求是默认不发送Cookie信息的，如果要把cookie 信息发送到服务<br>器，那么需要在ajax 请求时设置 xhr 的属性 withCredentials 为 true，而且服务器端也需要设置响应头部 Access-Control-Allow-Credentials: true。前端代码如下所示：<br>var xhr = new XMLHttpRequest();<br>xhr.withCredentials = true;</li></ol></li><li><ol start="5"><li>需要注意的是，如果要发送cookie，Access-Control-Allow-Origin就不能<br>设置为*号了，必须指定为与请求的网页一致的域名。而且cookie也是遵循同源策略的，只有在服务器配置Access-Control-Allow-Origin设置过的域名的cookie才会上传，其他域名的cookie并不会上传。<h2 id="非简单请求："><a href="#非简单请求：" class="headerlink" title="非简单请求："></a>非简单请求：</h2>比如请求方法是put或者delete。</li></ol></li><li><ol><li>发送预检请求</li></ol></li></ul><p>浏览器在发送真正的请求之前，会先发送一个“预检”请求给服务器。如下图所示，在我点击删除按钮后，浏览器发出两个remove请求。</p><p>第一个remove请求就是预检请求，这个请求使用 OPTIONS 方法，表示是来询问的。发送的头信息如下图所示。</p><p>Origin：表示来自哪个域名，与简单请求是相同的。<br>Access-Control-Request-Method: （必须）请求自身使用的方法，当前是delete。<br>Access-Control-Request-Headers: （可选）自定义的头部信息，多个头部以逗号分隔，默认是conten-type。</p><ul><li><ol start="2"><li>预检请求得到的回应</li></ol></li></ul><p>发送这个请求后，服务器检查上述三个字段后，可以决定是否允许这种类型的跨域请求，可以做出回应。如上图的Response Headers里红色框住的部分，这三个字段都是服务器端返回来的。<br>•    Access-Control-Allow-Origin：（必须）表示该域名可以请求数据，与简单的请求相同。<br>•    Access-Control-Allow-Methods: （必须）允许的方法，多个方法以逗号分隔。<br>•    Access-Control-Allow-Headers: （可选）允许的头部，多个头部以逗号分隔。</p><ul><li><ol start="3"><li>浏览器正常的请求和回应</li></ol></li></ul><p>一旦服务器通过了预检请求，也就是匹配上了，就会正常发出cors请求，和简单请求一样。如下图所示。</p><p>再次执行删除操作，还是会发出两次remove请求。</p><h1 id="cors总结"><a href="#cors总结" class="headerlink" title="cors总结"></a>cors总结</h1><ul><li><p>优点</p></li><li><ol><li>CORS 通信与同源的 AJAX 通信没有差别，代码完全一样，容易维护，只是在发送cookie时需要多一行设置xhr的withCredentials为true。</li></ol></li><li><ol start="2"><li>支持所有类型的 HTTP 请求。</li></ol></li><li><p>缺点</p></li><li><p>1.存在兼容性问题，特别是 IE10 以下的浏览器。</p></li><li>2.发送非简单请求时会多一次请求，预检请求。<h1 id="结合业务场景实现的具体代码"><a href="#结合业务场景实现的具体代码" class="headerlink" title="结合业务场景实现的具体代码"></a>结合业务场景实现的具体代码</h1>本例子是使用基于koa2的eggjs框架实现后端的跨域设置。也可以使用原生nodejs，express，koa2实现，或者使用java实现，实现方法大同小异，都是设置以下三个字段：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); // 可接受的域名</span><br><span class="line">response.setHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST,OPTIONS,GET,DELETE&quot;);//可接受的请求方法</span><br><span class="line">response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;)// 是否同意接受cookie</span><br></pre></td></tr></table></figure></li></ul><p>每种后端语言的设置方式就不一一列举了,下面给出eggjs的跨域设置。</p><h2 id="eggjs跨域设置"><a href="#eggjs跨域设置" class="headerlink" title="eggjs跨域设置"></a>eggjs跨域设置</h2><ul><li><p>1.安装egg-cors包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install egg-cors --save</span><br></pre></td></tr></table></figure></li><li><p>2.在Config/plugin.js里设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">exports.cors = &#123;</span><br><span class="line">  enable: true,</span><br><span class="line">  package: &apos;egg-cors&apos;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>3.在config/config.default.js里设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">config.cors = &#123;</span><br><span class="line">    origin: &apos;http://localhost:9898&apos;,</span><br><span class="line">    allowMethods: &apos;GET, POST, PUT, DELETE&apos;,</span><br><span class="line">    credentials: true,</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></li><li><p>4.设置前端发送cookie到服务器端，由于本例子前端请求使用axios，配置方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.withCredentials = true; //让axios自动发送服务器cookie</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;什么是cors&quot;&gt;&lt;a href=&quot;#什么是cors&quot; class=&quot;headerlink&quot; title=&quot;什么是cors&quot;&gt;&lt;/a&gt;什么是cors&lt;/h1&gt;&lt;p&gt;CORS ，全称是Cross-origin resource sharing，意思是跨域资源共享，众
      
    
    </summary>
    
    
      <category term="cors 跨域" scheme="https://github.com/liangzhm/tags/cors-%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>针对git多账号ssh-key的设置方法（github和gitlab）</title>
    <link href="https://github.com/liangzhm/2019/02/02/%E9%92%88%E5%AF%B9git%E5%A4%9A%E8%B4%A6%E5%8F%B7ssh-key%E7%9A%84%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95%EF%BC%88github%E5%92%8Cgitlab%EF%BC%89/"/>
    <id>https://github.com/liangzhm/2019/02/02/针对git多账号ssh-key的设置方法（github和gitlab）/</id>
    <published>2019-02-02T09:54:36.000Z</published>
    <updated>2019-02-02T10:23:52.853Z</updated>
    
    <content type="html"><![CDATA[<p>日常使用git作为仓库使用时，会遇到以下情况，有一个github账号（私人博客的）和一个gitlab账号（公司的），提交时会遇到没有公钥权限的情况。下面详细说一下如何设置。</p><h2 id="1-清除git的全局设置"><a href="#1-清除git的全局设置" class="headerlink" title="1.清除git的全局设置"></a>1.清除git的全局设置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config -global --list 可查看之前对 git 设置过全局的 user.name 和 user.email</span><br></pre></td></tr></table></figure><h4 id="如果有，必须删除该设置"><a href="#如果有，必须删除该设置" class="headerlink" title="如果有，必须删除该设置"></a>如果有，必须删除该设置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global --unset user.name &quot;你的名字&quot;</span><br><span class="line">git config --global --unset user.email &quot;你的邮箱&quot;</span><br></pre></td></tr></table></figure><h2 id="2-生成新的-SSH-keys"><a href="#2-生成新的-SSH-keys" class="headerlink" title="2.生成新的 SSH keys"></a>2.生成新的 SSH keys</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;heye@**.com&quot; 名称是gitlab_id_rsa</span><br><span class="line">ssh-keygen -t rsa -C &quot;heye@gmail.com&quot; 名称是github_id_rsa</span><br></pre></td></tr></table></figure><h2 id="3-提供公钥给服务器"><a href="#3-提供公钥给服务器" class="headerlink" title="3.提供公钥给服务器"></a>3.提供公钥给服务器</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 复制 ~/.ssh/gitlab_id_rsa.pub文件内容，进入gitlab / profile / SSH Keys，将公钥内容添加至 gitlab 。</span><br><span class="line">2. 复制 ~/.ssh/github_id_rsa.pub文件内容，进入github / setting / SSH and GPG keys / New SSH key 将公钥内容添加至 github 。</span><br></pre></td></tr></table></figure><h2 id="4-更新SSH配置文件，用户级别的配置文件-ssh-config"><a href="#4-更新SSH配置文件，用户级别的配置文件-ssh-config" class="headerlink" title="4.更新SSH配置文件，用户级别的配置文件~/.ssh/config"></a>4.更新SSH配置文件，用户级别的配置文件~/.ssh/config</h2><p>在~/.ssh/目录执行touch config，若有，先删除。<br>打开config，输入以下配置<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#default gitLab 公司账号</span><br><span class="line">Host git.**.com</span><br><span class="line">HostName git.**.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">User heye@**.com</span><br><span class="line">IdentityFile ~/.ssh/gitlab_id_rsa</span><br><span class="line"></span><br><span class="line">#add gitHub 我的博客</span><br><span class="line">Host github.com</span><br><span class="line">HostName github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">User heye@gmail.com</span><br><span class="line">IdentityFile ~/.ssh/github_id_rsa</span><br></pre></td></tr></table></figure></p><h2 id="5-配置仓库用户信息"><a href="#5-配置仓库用户信息" class="headerlink" title="5.配置仓库用户信息"></a>5.配置仓库用户信息</h2><p>依次的加载顺序是</p><ol><li>~/.gitconfig 中的用户信息</li><li>当前项目使用的仓库的git目录中的config文件，也就是.git/config<br>因为不同仓库连接不同的服务器，所用的git用户信息也不同。<br>可以把常用的git用户信息配置到 ~/.gitconfig 中，不常用的我们在仓库中单独配置。以常用 gitlab 为例，这样就把公司账号设为了全局的默认用户信息。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;heye2&quot;</span><br><span class="line">git config --global user.email &quot;heye@**.com&quot;</span><br></pre></td></tr></table></figure></li></ol><p>进入本地 github 仓库配置 git 用户信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --local user.name &quot;heye&quot;</span><br><span class="line">git config --local user.email &quot;heye@gmail.com&quot;</span><br></pre></td></tr></table></figure></p><p>不设置这一步的话，直接到第6步也会提示进行这一步的。</p><h2 id="6-测试github和gitlab账号通了没"><a href="#6-测试github和gitlab账号通了没" class="headerlink" title="6. 测试github和gitlab账号通了没"></a>6. 测试github和gitlab账号通了没</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@git.**.com</span><br></pre></td></tr></table></figure><p>连续输三次密码后，再次进行测试连接。<br>显示连接已经成功。<br>在git commit 时，提示没有用户信息<br>随之设置用户信息<br>于是就可以正常的提交代码到远程仓库了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></p><p>当看到测试得到的结果是success时，说明已经正确的设置可github和gitlab的ssh key了。<br>这样博客文件也可以正常的进行pull 和push 以及hero d -g 部署和发布了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;日常使用git作为仓库使用时，会遇到以下情况，有一个github账号（私人博客的）和一个gitlab账号（公司的），提交时会遇到没有公钥权限的情况。下面详细说一下如何设置。&lt;/p&gt;
&lt;h2 id=&quot;1-清除git的全局设置&quot;&gt;&lt;a href=&quot;#1-清除git的全局设置&quot; 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>2019，对自己说加油</title>
    <link href="https://github.com/liangzhm/2019/02/02/2019%EF%BC%8C%E5%AF%B9%E8%87%AA%E5%B7%B1%E8%AF%B4%E5%8A%A0%E6%B2%B9/"/>
    <id>https://github.com/liangzhm/2019/02/02/2019，对自己说加油/</id>
    <published>2019-02-02T09:24:58.000Z</published>
    <updated>2019-02-02T09:47:26.216Z</updated>
    
    <content type="html"><![CDATA[<p>转眼间，来到新的工作单位已经将近半年了，在这段时间里，学到了很多，也得到了很多，心态比以前成熟了许多。希望2019，工作能上一个台阶，也希望我身边所有人越来越好。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;转眼间，来到新的工作单位已经将近半年了，在这段时间里，学到了很多，也得到了很多，心态比以前成熟了许多。希望2019，工作能上一个台阶，也希望我身边所有人越来越好。&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>后台系统登录鉴权步骤记录</title>
    <link href="https://github.com/liangzhm/2018/06/16/%E5%90%8E%E5%8F%B0%E7%B3%BB%E7%BB%9F%E7%99%BB%E5%BD%95%E9%89%B4%E6%9D%83%E6%AD%A5%E9%AA%A4%E8%AE%B0%E5%BD%95/"/>
    <id>https://github.com/liangzhm/2018/06/16/后台系统登录鉴权步骤记录/</id>
    <published>2018-06-16T10:04:36.000Z</published>
    <updated>2019-02-02T09:47:26.219Z</updated>
    
    <content type="html"><![CDATA[<h1 id="登录鉴权步骤"><a href="#登录鉴权步骤" class="headerlink" title="登录鉴权步骤"></a>登录鉴权步骤</h1><h2 id="1-路由里写鉴权"><a href="#1-路由里写鉴权" class="headerlink" title="1. 路由里写鉴权"></a>1. 路由里写鉴权</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.post(&apos;/api/login&apos;, app.passport.authenticate(&apos;local&apos;, &#123; successRedirect: &apos;/api/login/authCallback&apos; &#125;));</span><br></pre></td></tr></table></figure><h2 id="2-config-plugin-js-同时安装egg-passport模块"><a href="#2-config-plugin-js-同时安装egg-passport模块" class="headerlink" title="2. // config/plugin.js  同时安装egg-passport模块"></a>2. // config/plugin.js  同时安装egg-passport模块</h2><p>exports.passport = {<br>  enable: true,<br>  package: ‘egg-passport’,<br>};</p><h2 id="3-app-js里导入-导入鉴权逻辑"><a href="#3-app-js里导入-导入鉴权逻辑" class="headerlink" title="3.app.js里导入 导入鉴权逻辑"></a>3.app.js里导入 导入鉴权逻辑</h2><p>module.exports = app =&gt; {<br>    require(‘./init/session’)(app)<br>    require(‘./init/passLocal’)(app)<br>};</p><h2 id="4-init-passLocal-js-里加入鉴权的逻辑"><a href="#4-init-passLocal-js-里加入鉴权的逻辑" class="headerlink" title="4.init/passLocal.js 里加入鉴权的逻辑"></a>4.init/passLocal.js 里加入鉴权的逻辑</h2><h2 id="5-init-session-js-里有model为Session的函数，所以要新建model在app文件夹下，new-Schema"><a href="#5-init-session-js-里有model为Session的函数，所以要新建model在app文件夹下，new-Schema" class="headerlink" title="5.init/session.js 里有model为Session的函数，所以要新建model在app文件夹下，new Schema({ })"></a>5.init/session.js 里有model为Session的函数，所以要新建model在app文件夹下，new Schema({ })</h2><h2 id="6-调试时发现post请求，但是url后面还是带着参数，仔细查看文档，原来是axios请求参数为data时会自动序列化为json格式的，在post-的body里，export-const-fqLogin"><a href="#6-调试时发现post请求，但是url后面还是带着参数，仔细查看文档，原来是axios请求参数为data时会自动序列化为json格式的，在post-的body里，export-const-fqLogin" class="headerlink" title="6.调试时发现post请求，但是url后面还是带着参数，仔细查看文档，原来是axios请求参数为data时会自动序列化为json格式的，在post 的body里，export const fqLogin = {"></a>6.调试时发现post请求，但是url后面还是带着参数，仔细查看文档，原来是axios请求参数为data时会自动序列化为json格式的，在post 的body里，export const fqLogin = {</h2><p>  async login(data) { // 注意: 这个地方要写data，axios会序列化为json<br>     return await http({<br>       url: ‘/myApi/api/login’,<br>       method: ‘post’,<br>       data<br>     })<br>  }<br>}</p><h2 id="7-init-passLocal-js里面。先去验证req-body里验证码和session-code-是否一致，如果一致，才往下走查找用户的逻辑"><a href="#7-init-passLocal-js里面。先去验证req-body里验证码和session-code-是否一致，如果一致，才往下走查找用户的逻辑" class="headerlink" title="7. init/passLocal.js里面。先去验证req.body里验证码和session.code 是否一致，如果一致，才往下走查找用户的逻辑"></a>7. init/passLocal.js里面。先去验证req.body里验证码和session.code 是否一致，如果一致，才往下走查找用户的逻辑</h2><h2 id="8-查找用户时，调用ctx-service-users-login-user-服务，于是，在service下面建users-js文件，里面其实就是调用数据库方法查找数据，如果找到了，那么登录成功。自此，鉴权登录逻辑完成。"><a href="#8-查找用户时，调用ctx-service-users-login-user-服务，于是，在service下面建users-js文件，里面其实就是调用数据库方法查找数据，如果找到了，那么登录成功。自此，鉴权登录逻辑完成。" class="headerlink" title="8. 查找用户时，调用ctx.service.users.login(user) 服务，于是，在service下面建users.js文件，里面其实就是调用数据库方法查找数据，如果找到了，那么登录成功。自此，鉴权登录逻辑完成。"></a>8. 查找用户时，调用ctx.service.users.login(user) 服务，于是，在service下面建users.js文件，里面其实就是调用数据库方法查找数据，如果找到了，那么登录成功。自此，鉴权登录逻辑完成。</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;登录鉴权步骤&quot;&gt;&lt;a href=&quot;#登录鉴权步骤&quot; class=&quot;headerlink&quot; title=&quot;登录鉴权步骤&quot;&gt;&lt;/a&gt;登录鉴权步骤&lt;/h1&gt;&lt;h2 id=&quot;1-路由里写鉴权&quot;&gt;&lt;a href=&quot;#1-路由里写鉴权&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
  </entry>
  
</feed>
