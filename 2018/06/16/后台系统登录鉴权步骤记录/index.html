<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 后台系统登录鉴权步骤记录 · 和叶的空间</title><meta name="description" content="后台系统登录鉴权步骤记录 - liangzhm"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://github.com/liangzhm/atom.xml" title="和叶的空间"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/liangzhm" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">后台系统登录鉴权步骤记录</h1><div class="post-info">Jun 16, 2018</div><div class="post-content"><h1 id="登录鉴权步骤"><a href="#登录鉴权步骤" class="headerlink" title="登录鉴权步骤"></a>登录鉴权步骤</h1><h2 id="1-路由里写鉴权"><a href="#1-路由里写鉴权" class="headerlink" title="1. 路由里写鉴权"></a>1. 路由里写鉴权</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.post(&apos;/api/login&apos;, app.passport.authenticate(&apos;local&apos;, &#123; successRedirect: &apos;/api/login/authCallback&apos; &#125;));</span><br></pre></td></tr></table></figure>
<h2 id="2-config-plugin-js-同时安装egg-passport模块"><a href="#2-config-plugin-js-同时安装egg-passport模块" class="headerlink" title="2. // config/plugin.js  同时安装egg-passport模块"></a>2. // config/plugin.js  同时安装egg-passport模块</h2><p>exports.passport = {<br>  enable: true,<br>  package: ‘egg-passport’,<br>};</p>
<h2 id="3-app-js里导入-导入鉴权逻辑"><a href="#3-app-js里导入-导入鉴权逻辑" class="headerlink" title="3.app.js里导入 导入鉴权逻辑"></a>3.app.js里导入 导入鉴权逻辑</h2><p>module.exports = app =&gt; {<br>    require(‘./init/session’)(app)<br>    require(‘./init/passLocal’)(app)<br>};</p>
<h2 id="4-init-passLocal-js-里加入鉴权的逻辑"><a href="#4-init-passLocal-js-里加入鉴权的逻辑" class="headerlink" title="4.init/passLocal.js 里加入鉴权的逻辑"></a>4.init/passLocal.js 里加入鉴权的逻辑</h2><h2 id="5-init-session-js-里有model为Session的函数，所以要新建model在app文件夹下，new-Schema"><a href="#5-init-session-js-里有model为Session的函数，所以要新建model在app文件夹下，new-Schema" class="headerlink" title="5.init/session.js 里有model为Session的函数，所以要新建model在app文件夹下，new Schema({ })"></a>5.init/session.js 里有model为Session的函数，所以要新建model在app文件夹下，new Schema({ })</h2><h2 id="6-调试时发现post请求，但是url后面还是带着参数，仔细查看文档，原来是axios请求参数为data时会自动序列化为json格式的，在post-的body里，export-const-fqLogin"><a href="#6-调试时发现post请求，但是url后面还是带着参数，仔细查看文档，原来是axios请求参数为data时会自动序列化为json格式的，在post-的body里，export-const-fqLogin" class="headerlink" title="6.调试时发现post请求，但是url后面还是带着参数，仔细查看文档，原来是axios请求参数为data时会自动序列化为json格式的，在post 的body里，export const fqLogin = {"></a>6.调试时发现post请求，但是url后面还是带着参数，仔细查看文档，原来是axios请求参数为data时会自动序列化为json格式的，在post 的body里，export const fqLogin = {</h2><p>  async login(data) { // 注意: 这个地方要写data，axios会序列化为json<br>     return await http({<br>       url: ‘/myApi/api/login’,<br>       method: ‘post’,<br>       data<br>     })<br>  }<br>}</p>
<h2 id="7-init-passLocal-js里面。先去验证req-body里验证码和session-code-是否一致，如果一致，才往下走查找用户的逻辑"><a href="#7-init-passLocal-js里面。先去验证req-body里验证码和session-code-是否一致，如果一致，才往下走查找用户的逻辑" class="headerlink" title="7. init/passLocal.js里面。先去验证req.body里验证码和session.code 是否一致，如果一致，才往下走查找用户的逻辑"></a>7. init/passLocal.js里面。先去验证req.body里验证码和session.code 是否一致，如果一致，才往下走查找用户的逻辑</h2><h2 id="8-查找用户时，调用ctx-service-users-login-user-服务，于是，在service下面建users-js文件，里面其实就是调用数据库方法查找数据，如果找到了，那么登录成功。自此，鉴权登录逻辑完成。"><a href="#8-查找用户时，调用ctx-service-users-login-user-服务，于是，在service下面建users-js文件，里面其实就是调用数据库方法查找数据，如果找到了，那么登录成功。自此，鉴权登录逻辑完成。" class="headerlink" title="8. 查找用户时，调用ctx.service.users.login(user) 服务，于是，在service下面建users.js文件，里面其实就是调用数据库方法查找数据，如果找到了，那么登录成功。自此，鉴权登录逻辑完成。"></a>8. 查找用户时，调用ctx.service.users.login(user) 服务，于是，在service下面建users.js文件，里面其实就是调用数据库方法查找数据，如果找到了，那么登录成功。自此，鉴权登录逻辑完成。</h2></div></article></div></main><footer><div class="paginator"><a href="/2019/02/02/2019，对自己说加油/" class="prev">PREV</a></div><div id="comment"></div><div id="comment2"><script src="https://cdnjs.cat.net/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script id="dsq-count-scr1" src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script id="dsq-count-scr" src="//unpkg.com/valine/dist/Valine.min.js"></script><script>(function() {
    new Valine({
        el: '#comment',
        notify: false,
        verify: false,
        appId: 'B3xcjTWq77EgT99KmwW2D037-gzGzoHsz',
        appKey: 'qDSExhsQY3zUDDUz3QvjjWcc',
        placeholder: 'just go go',
        path: window.location.pathname,
        avatar: 'mm'
    });
})</script></div><!--include partial/comment--><div class="copyright"><p>© 2015 - 2019 <a href="https://github.com/liangzhm">liangzhm</a>.</p><!--p © #{year} #[a(href=config.url)!= config.author], powered by #[a(href=hexoURL, target="_blank") Hexo] and #[a(href=apolloURL, target="_blank") hexo-theme-apollo].--></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>